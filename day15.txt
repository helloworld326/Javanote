
容器类型：
	数组和StringBuffer;

数组和集合的区别：
	1.长度不同：
		数组的长度固定，集合长度可变；

	2.内容不同：
		数组存储的是同一类型的元素,而集合存储的是不同类型的元素;

	3.元素的数据类型问题：
		数组类存储基本数据类型,也可以存储引用数据类型;而集合只能存储引用类型,集合就是用来装对象的;
	集合特点：
		只能用于存储对象,长度可变,可以存储不同的数据类型;

Collection 是集合的顶层接口,他的子体系有重复的，有唯一的，有有序的，有无序的;

Collection的功能:
	1.添加功能;
		boolean add(Object obj);
		boolean addAll(Collection c);添加一个集合的元素;
	2.删除功能;
		void clear(Object obj):移除所有元素;
		void removeAll(Collection c):移除一个集合的元素;(是一个还是所有),只要有一个元素被移除了,返回值就是true;
	3.判断功能;
		boolean contains(Object obj);判断集合是否包含指定元素;
		boolean containsAll(Collection c);判断集合是否包含指定的集合元素;(是一个还是所有),只有包含所有的元素，才返回true;
		boolean isEmpty();判断集合元素是否为空;
	4.获取功能;
		Iterator<E> interator()(重点);
	5.长度功能;  
		int size();集合中元素个数;
		面试题：数组有没有length	方法？字符串有没有length()方法呢？集合有没有length()方法呢？
	6.交集功能;
		boolean retainAll(Collection c):调用者集合保存交集的内容;该方法有交集就返回true;
			A, B两个集合,A对b做交集,最终的结果保存在A中,B不发生变化,返回值表示对的是A是否发生变化;
	7.把集合转换为数组:
		Object[] toArray();

Object next():获取元素，并移动位置到下一个元素上；

Iterator:
	迭代器，是遍历集合的一种方式;依赖集合的存在而存在;

NoSuchElementException:没有这样的元素，因为已经找到最后了；

note:
	1.自己的类名不要和我们学习使用的API的类名一样；
	2.复制代码的时候，容易把那类的代码的包也导过来；不要多次使用it.next()方法;

集合的使用步骤：
	1.创建集合对象; Collect c = new ArrayList();
	2.创建元素对象; 
	3.把元素添加到集合; c.add();
	4.遍历集合;
		(1) 通过集合对象获取迭代器对象
		(2) 通过迭代器对象的hasnext()方法判断是否还有可以遍历的元素;
		(3) 通过迭代器对象的next()方法获取元素并移动到下一个元素的位置;

迭代器为什么设计成一个接口而不是类呢？
	集合类的数据结构是不同的,所以存储的方式和遍历的方式是不一样的。真正实现的具体子类是以内部类的形式体现的;

List集合的特点：
	有序(存储和取出的元素顺序一致)，可重复的；

List集合特有的便利功能:
	size()和get()方法结合;
	Object previous(),返回上一个元素,可以是的List集合逆向遍历，但要先正向遍历才能逆向遍历，一般无意义(因为初始时的位置是在第一个)；

并发修改异常的原因以及解决办法:
	ConcurrentModificationException:
			检测到并发修改，但不允许修改,会抛出此异常;

			产生的原因:
				迭代器依赖集合存在的，集合中新添加的元素，迭代器并不知道，所以并发修改异常；即迭代器遍历集合	时，不允许修改集合元素；
			解决办法：
				迭代器迭代元素，迭代器修改元素；
					元素添加在迭代的位置；
				集合遍历元素，集合修改元素(普通for)； 
					元素添加在集合最后位置；

List(面试题List的子类特点)
	ArrayList:
		底层结构是数组，查询快，增删慢，线程不安全，效率高；
	Vector:
		底层结构是数组，查询快，增删慢，线程安全，效率低，普遍不用；
	LinkedList:
		底层数据结构是链表，查询慢，增删快，线程不安全，效率高；
	
	要安全？
		要：Vector(即使安全，也不用这个，后面有替代)
		不要：
			查询多：ArrayList(用的比较多)
			增删多：LinkedList