多线程：不是提高程序的执行速度，其实是为了提高应用程序的使用率；线程的执行具有随机性；

java程序的运行原理：
	由java命令启动JVM，JVM启动就相当于启动一个进程。接着该进程创建了一个主线程去调用main方法；
虚拟机的启动是多线程的；

创建线程的两种方式：
	1.继承Thread类
		步骤：
			(1)自定义类的MyThread继承Thread类
			(2)MyThread类里面重写run()方法
				不是类中的所有方法都要被多线程执行，此时，为了区分哪些代码能够被线程执行，java
				提供了Thread类中的run()方法，用来包含哪些被线程执行的代码。
				(需要被多线程执行的代码放在run()方法里)
			(3)创建对象
			(4)启动线程
	2.实现Runnable接口
		步骤：
			1.自定义类实现Runnable接口
			2.重写run()方法  
			3.创建Runnable类的对象
			4.创建Thread类的对象，并把步骤3的对象作为构造参数传递;
		(解决单继承带来的局限性,适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效的
		分离，较好的体现了面向对象的设计思想)
			

面试题：
	1.run()和start()的区别：
		run()：仅仅是封装被线程执行的代码，直接调用仅仅是普通的方法而已；
		start()：首先启动线程，然后由JVM去调用线程的run()方法(包含run()方法)

IllegalThreadStateException:同一个线程被调用多次,需要创建多个线程;
	
针对不是Thread类的子类中如何获取线程对象名称？
	public static Thread currentThread():返回当前执行的线程对象，然后调用getName()方法；
	
java中使用抢占式调用模型，优先级相等时，会随机选择一个线程获得时间片，即执行权;
线程默认优先级是5；范围：1-10；线程优先级高仅仅表示该线程获得执行权的概率高；

线程控制：
	public final void jion():等待线程终止;
	public final void yield():暂停当前执行的对象，并执行其他线程;(一定程度上做到礼让)
	public void interrupt():中断线程，把线程的状态终止，并抛出一个InterruptedException。
	
面试题：
	线程的生命周期：
	1.新建：创建线程对象；
	2.就绪：进入就绪队列，等待调度获取执行权；
	3.运行
		阻塞，被剥夺执行权；
	4.死亡：线程对象变成垃圾，等待被回收；
	
day23 线程生命周期图解；


抽象类：
抽象类一定是个父类，因为抽象类时不断抽取共性需求而来的。
抽象类中是可以不定义抽象方法的，此时仅仅是不让该类创建对象，用于某些特殊的设计需要。
设计时由具体类抽取出抽象类，而开发阶段应该先定义抽象父类，再根据不同需求由父类定义子类。
子抽象类可以实现父抽象类的抽象方法，但须要其具体子类实现，可以使用多态；

this和super的区别：
1.this记录调用对象的地址，在内存中是实际存在的一块区域；
2.super在内存中并没有具体存储区域，只是为了区分那些内容是父类的内容；
3.在构造方法中，使用this(形参)可以调用本类的构造方法，但是不能构成死循环，其位置只能出现在方法的第一行；
this和super不能同时出现在一个构造方法的方法

方法重写的注意事项：
1.子类重写父类的方法，权限不能比父类低；
2.方法格式必须和父类一样；
3.访问方式必须一致(同为static或者非static)

构造代码块：
	可以把构造方法里面的共有代码提取出来；构造方法中隐式三步的第三步；构造代码块优先于构造方法执行;
	
同步的前提：
	1.多个线程；
	2.多个线程使用的同一个对象；
	弊端：多个线程时，每个线程都会去判断同步上的锁，很耗费资源，无形中降低运行效率；
	
synchronized的对象可以是任意对象;
同步方法的对象是this；
静态方法的对象是当前类的class文件 

线程安全的类：
	StringBuffer sb = new StringBuffer();
	Vector<String> v = new Vector<String>();
	Hashtable<String,String> h = new Hashtable<String,String>();
	
多线程安全问题的原因：
	1.是否有多线程环境
	2.是否有共享数据
	3.是否有多条语句操作共享

用Collection工具类的方法可以把一个线程不安全的集合类变成一个安全的集合类；